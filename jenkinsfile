pipeline {
    agent any 

     parameters {
        booleanParam defaultValue: true,  description: 'True: generate TF AWS resources', name: 'applyTF'
        string defaultValue: 'latest', name: 'ImgTag', trim: true

    }   

    environment {
        AWS_CRED = "AWS_sortlog"
        AWS_REGION = "ap-southeast-2"

        ECR_REPO = "sortlog-prod"
        IMAGE_NAME = "$ECR_REPO"
        IMAGE_TAG = "${params.ImgTag}"
        ECR_URL = "003374733998.dkr.ecr.ap-southeast-2.amazonaws.com"
        
        SORTLOG_DEV_IMAGE = "sortlog-dev"
        SORTLOG_PROD_IMAGE = "sortlog-prod"

        // tf
        APP_ENV = "Dev-UAT"
    }   


    stages {

        stage ('tf-dev'){
            steps {
                withAWS(credentials: AWS_CRED, region: AWS_REGION){
                    script {
                        if (env.BRANCH_NAME == 'dev' && params.applyTF){
                             sh  '''
                            terraform init -input=false
                            terraform workspace select $APP_ENV || terraform workspace new $APP_ENV
                            terraform destroy \
                               -var="env_prefix=$APP_ENV"\
                               --auto-approve
                            '''
                        script {
                            front_domain_name = sh(returnStdout: true, script: "terraform output front_domain_name")
                            back_domain_name = sh(returnStdout: true, script: "terraform output back_domain_name")
                            cdn = sh(returnStdout: true, script: "terraform output cdn")
                            alb_dns_name = sh(returnStdout: true, script: "terraform output alb_dns_name")
                        }
                        sh  '''
                            echo ${front_domain_name}
                            echo ${back_domain_name}
                            echo ${cdn}
                            echo ${alb_dns_name}
                        '''
                        }
                    }
                }
            }
        }

        // stage('dev'){
        //     // when {
        //     //     branch 'dev'
        //     // }
        //     // when {
        //     //     expression {return params.applyTF && }
        //     // }

        //     steps {
        //         withAWS(credentials: AWS_CRED, region: AWS_REGION){

        //             script {
        //                 if (env.BRANCH_NAME == 'dev' && params.applyTF){
        //                     echo "Upload Docker Image to ECR"
        //                     script {
        //                     sh '''
        //                         aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_URL
        //                         docker tag $IMAGE_NAME:${params.ImgTag} $ECR_URL/$IMAGE_NAME:${params.ImgTag} 
        //                         docker push $ECR_URL/$IMAGE_NAME:${params.ImgTag}
        //                     '''
        //                     }
        //                 }
        //             }
        //         }
        //     }
        // } 
    }

    post {
        always {
            script {
                try{
                    // docker images -qa | xargs docker rmi -f
                    sh'''
                        docker rmi $(docker images -q)
                        docker system prune
                        cleanWs()
                    '''
                } catch (Exception e) {
                    echo "docker clean failed"
                }
            }
        
        }

        failure {
            // send message it was failsure
            echo "uhm... 我觉得不太行！"
        }

        success {
            // send message it was success
            echo "老铁！恭喜你，成功了呀!"
        }
    }
 
}